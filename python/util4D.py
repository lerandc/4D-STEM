#Module library for manipulating and processing simulated 4D STEM data
#Author: Luis Rangel DaCosta, lerandc@umich.edu
#Last comment date: 7-15-2018
#written for Python 3.6.5, using scipy 1.1.0, numpy 1.14.5

import os
import scipy.io as sio
import scipy.misc as smisc
import numpy as np
import re as regexp
import math

def loadImageFromMat(fname):                
    #loads an image array from a matlab file with file name "fname"
    #assumes that the only variable in the matlab file
    #fname is a string representing filename of the file
    img_array = sio.loadmat(fname)
    fields = sio.whosmat(fname)
    img_array = img_array[fields[0][0]]
    return img_array

def genCenters(centers,shiftRange):
    #generates a list of unique center points based off of input list of (X,Y) and shift range 
    #input centers is list of tuples (X,Y)
    #input shiftRange is positive integer
    #returns list of all possible iterations of original center list, 
    #shifted in X and Y by steps of 1 in range [-shiftRange, +shiftRange], inclusive
    #output format is list of tuples (X,Y)

    shifts = []
    for sx in range(-shiftRange,shiftRange+1):
        for sy in range(-shiftRange,shiftRange+1):
            shifts.append((sx,sy))

    outCenters = []
    for center in centers:
        for shift in shifts:
            outCenters.append(tuple(map(lambda x,y:x+y, center, shift)))

    return list(set(outCenters))

def addPoissonNoise(orig,scale):
    #applies poisson noise after first scaling image array from [0,x] to [0,scale]
    #orig is noiseless image matrix, scale is scaling factor to assign discrete probablities of electron counts
    #returns noisy image array
    scale /= np.max(orig)
    orig = orig * scale
    noisy = np.random.poisson(orig)
    return noisy

def prismMap(xlim, ylim):
    #creates a  two-dimensional list of two element vectors, where i,j in vecor
    #corresponds to base_Xi_Yj_FP#.mrc in standard prismatic output file
    #xlim and ylim are the number of probe stebs as integers in the respective dimensions, or,
    #as a 4D array, size[0],size[1] in [x,y,kx,ky]
    pMap = [[[y,x] for x in range(xlim)] for y in range(ylim)]
    return pMap

def get4Darray(base_name,base_ext,map_lim,imsize,folder):
    #loads images into npy array
    #imsize should be a tuple of (kx,ky)
    #map_lim should be a tuple of (x,y) where x,y are number of probe positions in their repsecitve dimension
    #base name and base_ext are strings corresponding to the regular file names prismatic outputs
    #folder is file path of the folder where the 4D images are located
    #images should have already been convereted to numpy arrays by this point
    #ex: base_name = '73_test_', base_ext = '_FPavg.npy'

    out_sz = map_lim + imsize
    output = np.zeros(out_sz,dtype=np.float32)
    for x in range(map_lim[0]):
        for y in range(map_lim[1]):
            output[x,y,:,:] = np.load(folder+base_name+'_X'+str(x)+'_Y'+str(y)+base_ext)

    return output

def createPACBED(radii,centers,out_name,out_ext,array_size,origCBEDarray,folder):
    #creates pacbed from series of CBED patterns by integrating patterns over a radius
    #from a given center in real space
    #radii is list of ints defining integration radii
    #centers is list of tuples [(X,Y)] note: typically this is generated by genCenters() prior to this step
    #out_name and out_ext are the name of the output file  and desired extension ex: 'Sr_PACBED', '.npy'
    #array size is tuple (X,Y) of size of imaging array in real space (# of pixels)
    #origCBEDarray is 4D array (x,y,kx,ky) of preloaded CBED patterns
    #folder is filepath of desired output folder as a string

    #grab size (kx,ky)
    imsize = tuple(origCBEDarray.shape[-2:])

    #make '1D' sequence of images (N,kx,ky)
    origCBEDarray = np.reshape(origCBEDarray,(np.prod(array_size),imsize[0],imsize[1]))

    #grab real space sizes
    xlim,ylim = array_size
    #create meshes corresponding to coordinates of probe position
    xm,ym = np.meshgrid(range(1,xlim+1),range(1,ylim+1))

    for radius in radii:
        for cent_x,cent_y in centers:
            #center probe positition meshes to current center
            xm_cent = xm-cent_x
            ym_cent = ym-cent_y
            #define probe position distance function
            dist = np.sqrt(xm_cent**2 + ym_cent**2)

            #intiliaze single float array to serve as target for CBED integration
            pacbed = np.zeros(imsize,dtype=np.float32)
            #make 1D list of logical values to select images if within integration radius
            mask = np.reshape(dist < radius,-1)

            #integrate images onto target array
            for i in range(len(mask)):
                if mask[i]:
                    pacbed += origCBEDarray[i,:,:]
            pacbed /= sum(mask)

            f_name = out_name+'_'+str(cent_x) + '_' + str(cent_y) + '_' + str(radius) + out_ext
            np.save(folder+f_name,pacbed)

def effSourceSize(source_size,pixel_size,base_name,base_ext,array_size,folder):
    #simulates point spread caused by finite source size of electrons in STEM experiment
    #by convolving CBED array in real space with a guassian kernel
    #source size is size of FWHM of finite electron source
    #pixel size is size of the pixel in real space NOT the real space sampling of potential
    #ie, pixel size is equivlant to the length of a probe step
    #base name is a string of the regular file name of prismatic 4D output
    #base ext should be the new ending string of the cropped images in k space
    #array size is (x,y) size of real space array of images
    #folder is file path where cbeds are located

    imsize = (np.load(folder+base_name+'_X0_Y0'+base_ext)).shape
    origCBEDarray = get4Darray(base_name,base_ext,array_size,imsize,folder)
    sigma = (source_size/pixel_size[0])/(2.355)
    kernel = gaussKernel(sigma,array_size[0])

    return convolve2D(origCBEDarray,kernel)

def convolve2D(CBEDarray,kernel):
    #convolves 4D cbed array in real space by a given gaussian kernel
    #CBED array is 4D array (x,y,kx,ky) of all CBED images in  a set
    #kernel is gaussian kernel os size (x,y) used to blur images

    #convolution operation is faster to apply in k-space
    #transform kernel into k-space
    fkernel = np.fft.fft2(kernel)
    kx,ky = CBEDarray.shape[-2:]
    #initialize result array
    result = CBEDarray
    for k in range(kx):
        for l in range(ky):
            #apply convolution for each pixel in (kx,ky) over the whole set of images in (x,y)
            result[:,:,k,l] = np.fft.ifft2(fkernel*np.fft.fft2(CBEDarray[:,:,k,l]))

    #finish by aligning CBED arrays in real space so that center exists at the center of the image array
    return np.fft.fftshift(result,axes=(0,1))
    
def getCoordsM(cell_dim,real_pixel):
    #cell_dim is either single x=y or list of cell dimensions x,y
    #real pixel is sampling of potential space as single x=y or list of x,y
    #recreates fourier space coordinates of 4D output as obtained in prismatic multislice

    #append singleton dimension to 2nd dimension
    if len(cell_dim) < 2:
        cell_dim.append(cell_dim[0])

    if len(real_pixel) < 2:
        real_pixel.append(real_pixel[0])

    #calculate the size in pixels of the output array
    im_size = [int(16*round(cell_dim[0] / (16*real_pixel[0])))]
    im_size.append(int(16*round(cell_dim[1] / (16*real_pixel[1]))))

    #redefine real space pixel size of potential space
    pixel_size = [cell_dim[0] / im_size[0]]
    pixel_size.append(cell_dim[1] / im_size[1])

    #get corresponding fourier coordinates of image
    qx = qCoords(im_size[0],pixel_size[0])
    qy = qCoords(im_size[1],pixel_size[1])

    #develop coordinate mesh and distance mesh
    qxa,qya = np.meshgrid(qx,qy)
    qdist = np.array(tuple(map(lambda x,y: (x**2 + y**2)**(0.5), qxa,qya)))


    #create antialiasing/downsampling filter (reduces calculated k-space by 2 in each dimension)
    qmask = np.zeros((im_size[1],im_size[0]))
    offset_x = im_size[0] // 4
    offset_y = im_size[1] // 4
    ndimx = im_size[0]
    ndimy = im_size[1]
    for y in range(ndimy // 2):
        for x in range(ndimx // 2):
            mod1 = (((y - offset_y) % ndimy + ndimy) % ndimy)
            mod2 = (((x - offset_x) % ndimx + ndimx) % ndimx)
            qmask[mod1,mod2] = 1

    #shift all k-space matrices so that zero frequency is in center
    qxa,qya = np.fft.fftshift(qxa),np.fft.fftshift(qya)
    qdist = np.fft.fftshift(qdist)
    qmask = np.fft.fftshift(qmask)
    output = {"qxa":qxa,"qya":qya,"qdist":qdist,"qmask":qmask}
    return output

def getCoordsP(cell_dim,real_pixel,int_f):
    #cell_dim is either single x=y or list of cell dimensions x,y
    #real pixel is sampling of potential space as single x=y or list of x,y
    #int_f is either single F or list [fx,fy] of interpolation factors
    #recreates fourier space coordinates of 4D output as obtained in prismatic PRISM
    
    #append singleton dimension to 2nd dimension
    if len(cell_dim) < 2:
        cell_dim.append(cell_dim[0])

    if len(real_pixel) < 2:
        real_pixel.append(real_pixel[0])

    if len(int_f) < 2:
        int_f.append(int_f[0])

    #calculate the size in pixels of the output array
    fx = int_f[0]
    fy = int_f[1]
    f_x = 4 * fx
    f_y = 4 * fy
    im_size = [f_x * round(cell_dim[0]/(real_pixel[0] * f_x))]
    im_size.append(f_y * round(cell_dim[0]/(real_pixel[0] * f_y)))

    pixel_size = [cell_dim[0] / im_size[0]]
    pixel_size.append(cell_dim[1] / im_size[1])

    #get corresponding fourier indices and coordinates of image
    qxInd = qInd(im_size[0])
    qyInd = qInd(im_size[1])

    qx = qCoords(im_size[0],pixel_size[0])
    qy = qCoords(im_size[1],pixel_size[1])

    #downsample fourier coordinates of output array accoording to interpolation factors
    return makeGrid(qx,qxInd,qy,qyInd,[fx,fy])

def qInd(im_size):
    #function to return indicies of k space coordinates as used in prismatic PRISM
    #imsize is number of pixels in 4D output
    q_ind = np.zeros((im_size/2,1))

    n = im_size
    n_quarter = im_size / 4
    for i in range(n_quarter):
        q_ind[i] = i + 1
        q_ind[i+n_quarter-1] = (i-n_quarter)+n+1

    return q_ind

def processCBED(cell_dim,real_pixel,E0,q_cut,q_cut_style,algorithm,folder,**kwargs):
    #best to use function as keyworded function to keep consistency in usage
    #cell dim is 2 element vector with dimension of simulation cell X, Y
    #real pixel is size of real pixel potential sampling in prismatic
    #E0 is energy of incident electron in volts
    #FP is number of frozen phonons
    #q_cut is distance in mrad to cut off the the CBED (reduces output size)
    #q_cut_style is 'circ' or 'rect', where circ is a simple distance cut off, and 'rect'
    #fits a box to the limits in kx and ky
    #algorithm is 'p' for PRISM and 'm' for multislice
    #if algorithm == 'p', an interpolation factor must be specified

    if (algorithm == 'p') and (not ('interpolation' in kwargs)):
        raise ValueError('Interpolation factor necessary for processing PRISM CBED patterns')

    if algorithm == 'p':
        f_int = kwargs['interpolation']
        qdict = getCoordsP(cell_dim,real_pixel,f_int)
    elif algorithm == 'm':
        f_int = 1 
        qdict = getCoordsM(cell_dim,real_pixel)
    else:
        raise ValueError('Check value of algorithm input, value should be \'p\' or \'m\'')

    #get wavelength of electron wave
    lambd = getLambda(E0)

    #takes raw CBED output and crops it to deisred distance in k-space
    if q_cut_style == 'circ':
       qdist = qdict['qdist']*lambd*1e3 #convert to mrad

       #reduces size of mask by antialiasing filter so that mask is same size as reduced output in multislice
       #this happens because originally, prismatic does not 
       if algorithm  == 'm': qdist = imageCrop(qdist*qdict['qmask'])
       dist_mask = qdist < q_cut
    elif q_cut_style == 'rect':
       qxa = qdict['qxa']*lambd*1e3 #convert to mrad
       qya = qdict['qya']*lambd*1e3

       #reduces size of mask by antialiasing filter so that mask is same size as reduced output in multislice
       if algorithm == 'm': qxa,qya = imageCrop(qxa*qdict['qmask']), imageCrop(qya*qdict['qmask'])
       qx_check = np.abs(qxa) < q_cut
       qy_check = np.abs(qya) < q_cut

       #get intersection of distance cut off in kx, ky
       dist_mask = np.logical_and(qx_check,qy_check)
    else:
        raise ValueError('Check value for q_cut_style, should be \'circ\' or \'rect\'')

    cbeds = [img for img in os.listdir(folder) if (('FPavg.npy' in img) and ('slice' + str(kwargs['slice']) in img))]
    for cbed in cbeds:
        tmp = np.squeeze(np.load(folder+cbed))
        #zero out values not in mask, then crop image to zero bounds
        tmp *= dist_mask*f_int**4
        np.save(folder+cbed[0:-4]+'_crop',imageCrop(tmp))


def getLambda(E0):
    #calculates wavelength of (in angstroms) of electron wave
    m = 9.19383e-31
    e = 1.602177e-19
    c = 299792458
    h = 6.62607e-34

    return 1e10*(h/(math.sqrt(2*m*e*E0)))/(math.sqrt(1+(e*E0)/(2*m*c*c)))

def qCoords(im_size,pix_size):
    #calculates k-space coordinates of prismatic 4D output as implemented in prismatic
    #imsize is size of image in pixels (kx,ky), and pix_size is reculated pixel size of potential space sampling
    q = np.zeros((im_size,1))
    nc = math.floor(im_size/2)
    dp = 1/(im_size * pix_size)
    for i in range(im_size):
        q[int((nc+i) % im_size)] = (i - nc) * dp

    return q

def makeGrid(qx,qxInd,qy,qyInd,f):
    #downsamples k-space of PRISM algorithm  4D output
    #qx,qy are vectors of k-coordinates
    #qxInd, qyInd are corresponding indices for coordinates
    qxa,qya = np.meshgrid(qx,qy)
    qxa_out = np.zeros((len(qxInd),len(qxInd)))
    qya_out = qxa_out

    #apply anti aliasing/initial downsample filter for PRISM coordinates
    for y in range(len(qyInd)):
        for x in range(len(qxInd)):
            qxa_out[y,x] = qxa[qyInd[y],qxInd[x]]
            qya_out[y,x] = qya[qyInd[y],qxInd[x]]

    #reduce k-space coordinates by factor f by utilizing every fth coordinate
    qxa_out_red = qxa_out[0:-1:f[1],0:-1:f[0]]
    qya_out_red = qya_out[0:-1:f[1],0:-1:f[0]]
    qdist = map(lambda x,y:(x**2+y**2)**(0.5),qxa_out_red,qya_out_red)

    output = {"qxa_out_red":qxa_out_red,"qya_out_red":qya_out_red,"qdist":qdist}
    return output

def gaussKernel(sigma,imsize):
    #creates gaussian filter kernel of size imsize x imsize and std. deviation sigma
    x,y = np.meshgrid(range(1,imsize+1),range(1,imsize+1))
    x = x - imsize//2
    y = y - imsize//2
    tmp = -(x**2+y**2)/(2*sigma**2)
    return (1/(2*np.pi*sigma**2))*np.exp(tmp)

def imageCrop(image):
    #removes zero borders of arbitrary image array
    #input is 2D image array
    miny = image.shape[0]
    maxy = 0
    for i in range(image.shape[1]):
        checks = np.where(np.abs(image[:,i]) > 0)
        if len(checks[0]):
            miny_t,maxy_t = np.min(checks), np.max(checks)
            if miny_t < miny: miny = miny_t
            if maxy_t > maxy: maxy = maxy_t

    minx = image.shape[1]
    maxx = 0
    for j in range(image.shape[0]):
        checks = np.where(np.abs(image[j,:]) > 0)
        if len(checks[0]):
            minx_t,maxx_t = np.min(checks), np.max(checks)
            if minx_t < minx: minx = minx_t
            if maxx_t > maxx: maxx = maxx_t
         
    return image[miny:maxy+1,minx:maxx+1]